# Published!

- [Live & Up-To-Date Article]( https://colbynwadman.substack.com/p/choose-your-constraints-wisely )

# Choose Your Constraints Wisely

> Projects and business models need hard constraints to succeed and not just be another copycat

As a software researcher, half the problem is choosing your constraints wisely. Ultimately, projects need hard constraints to succeed, and not just be another copycat which cannot be understated.

Furthermore, good constraints lead to optional convergence towards desirable outcomes, and in ways that cannot be perceived upfront by any human brain. 

Which nowadays matters far more than mere good ideas. Because every idea has been thought of before, but too little has been explored in such a freeform manner that ideas can spring up in a manner that cannot otherwise be predicted upfront. In this regard, LLMs like ChatGPT should make it plainly obvious that much can be done from randomly provisioned numbers and optional convergence via iteration. 

So what matters more are your constraints, not static ideas. 

## From Historical Precedence

With regard to software research: The Haskell Programming Language would not be what it is today without the hard and never before seen constraint of lazy evaluation. Just to emphasize the point, nowadays lazy evaluation is considered to be a design mistake, but it shaped all other aspects in such a way that made it was it is today and therefore it was a worthwhile design mistake. (Although nowadays I’d rather use PureScript if only tooling was better.)

More systematically: LLMs like ChatGPT begin with a series of randomly provisioned numbers, and via a method of iteration and refinement, the system converges towards an optional outcome and in a manner that cannot be predicted upfront. 

## More Generally

It is well known that harder problems yield more satisfactory results. From a software research perspective, projects need hard and technically challenging constraints to innovate, and preferably constraints not hitherto seem to make something new, and especially the kinda stuff that cannot be predicted in advance.

### Limits Of Foresight 

Consider the field of computability theory, it is well known that there are hard limits on what one can ‘know’ upfront from static information. Especially in the context of formal verification, where given some Turing complete program description, there are many insights one may wish to know (like the presence of bugs) that are generally impossible to answer upfront without some degree of evaluation. But while this is in the context of automation and its limits, such problems are **equally relevant to the limits of forethought** because ultimately the human brain is itself a computer and so is itself bound by the limits of computation.

> Nowadays while some programmers are trying to put all other programmers outta a job, some mathematicians have been trying to put all other mathematicians outta a job for at least a century.

This is the value I bring to the table, and is why my research style is very ‘evaluative’ and in an ‘exploratory’ manner. If you’re looking for those game-changer insights that cannot be known upfront (such as those concerning a business model), then I will come in and *compute* the problem to completion, and then report back on what has been uncovered along with any speculative advisory foresights from a refined context.

Most of the flourishment from the Haskell community could not be predicated upfront, but they chose their constraints wisely, and so the project converged towards a very desirable outcome without any upfront idea of what would come of it. 

Nowadays, LLMs like ChatGPT should make it plainly obvious that optimal convergence matters more than a mere upfront definition of a system. In my mind, business models are no different, what matters more are optional constraints such that a complex system can converge towards a desirable outcome. 


## Additionally

Another problem of the software researcher concerns generality or specificity. For instance should ‘X’ be implemented ad hoc or in a uniform manner? Typically greater uniformity is best and most elegant but requires more research to find the lowest common denominator approach. Although more practically, greater uniformity generally ensures support for things that don’t neatly fit into predefined categories.

Similarly concerning generality or specificity, is the question of parameterization or polymorphous systems. Such as a system that is agnostic to certain aspects that normally define such a system ad-hoc. How many systems out there can only work with a single implementation of something? Greater uniformly is generally most forward compatible as the landscape evolves and in turn as environmental perturbations change.

Likewise on a tangent, 

Greater uniformity facilitates greater diversity within a whole system, and after all in ecology is it well understood that diversity increases productivity and stability because species vary in their response to environmental fluctuations, ensuring that some will always maintain system function.
